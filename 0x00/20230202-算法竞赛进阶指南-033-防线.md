---
title: 算法竞赛进阶指南-33.防线
date: 2023-02-02 17:00:00
updated: 2023-02-02 17:00:00
index_img: /img/default/stardust.png
math: true
categories:
- 算法竞赛进阶指南
tags: 
- Algorithm
- C++
- 二分
excerpt: 算法竞赛进阶指南-0x00-基本算法
---

### 题目链接

 [算法竞赛进阶指南-33.防线](https://www.acwing.com/problem/content/122/)

达达学习数学竞赛的时候受尽了同仁们的鄙视，终于有一天......受尽屈辱的达达黑化成为了黑暗英雄怪兽达达。

就如同中二漫画的情节一样，怪兽达达打算毁掉这个世界。

数学竞赛界的精英 lqr 打算阻止怪兽达达的阴谋，于是她集合了一支由数学竞赛选手组成的超级行动队。

由于队员们个个都智商超群，很快，行动队便来到了怪兽达达的黑暗城堡的下方。

但是，同样强大的怪兽达达在城堡周围布置了一条“不可越过”的坚固防线。

防线由很多防具组成，这些防具分成了 $N$ 组。

我们可以认为防线是一维的，那么每一组防具都分布在防线的某一段上，并且同一组防具是等距离排列的。

也就是说，我们可以用三个整数 $S$， $E$ 和 $D$ 来描述一组防具，即这一组防具布置在防线的 $S，S + D，S + 2D，…，S + KD$($K∈ Z，S + KD≤E，S + (K + 1)D>E$)位置上。

黑化的怪兽达达设计的防线极其精良。

如果防线的某个位置有偶数个防具，那么这个位置就是毫无破绽的(包括这个位置一个防具也没有的情况，因为 $ 0 $ 也是偶数)。

只有有奇数个防具的位置有破绽，但是整条防线上也最多只有一个位置有奇数个防具。

作为行动队的队长，lqr 要找到防线的破绽以策划下一步的行动。

但是，由于防具的数量太多，她实在是不能看出哪里有破绽。

作为 lqr 可以信任的学弟学妹们，你们要帮助她解决这个问题。

#### 输入格式

输入文件的第一行是一个整数 $T$，表示有 $T$ 组互相独立的测试数据。

每组数据的第一行是一个整数 $N$。

之后 $ N $ 行，每行三个整数 $S_i，E_i，D_i$，代表第 $i$ 组防具的三个参数，数据用空格隔开。

#### 输出格式

对于每组测试数据，如果防线没有破绽，即所有的位置都有偶数个防具，输出一行 `"There's no weakness."`(不包含引号) 。

否则在一行内输出两个空格分隔的整数 $P$ 和 $C$，表示在位置 $P$ 有 $C$ 个防具。当然 $C$ 应该是一个奇数。

#### 数据范围

防具总数不多于$ 10^8 $,

$S_i \le E_i$,

$1 \le T \le 5$,

$N \le 200000$,

$0 \le S_i，E_i，D_i \le 2^{31}-1$

#### 输入样例：

```
3
2
1 10 1
2 10 1
2
1 10 1 
1 10 1 
4
1 10 1 
4 4 1 
1 5 1 
6 10 1
```

#### 输出样例：

```
1 1
There's no weakness.
4 3
```

### Method : 二分答案

原题：[[BJWC2008]秦腾与教学评估](https://www.luogu.com.cn/problem/P4403)

首先看到这道题，要求频繁在区间内插值，很容易联想到差分，但很遗憾，差分也难做等差数列的区间插值，因此差分思路走不通。遂看题解= =...， 没想到这居然是一道二分答案的题目。

这道题它十分神奇，神奇之处就在于有一个很强的性质,就是**序列中最多只有一个位置有奇数个防具(老师)**，所以，如果有解，那么**包含这个位置的点的前缀和必是奇数，不包含这个位置的点的前缀和必是偶数**。因此可以根据这个性质来构造二分答案。

另外，求前缀和的公式也很巧妙的利用到了等差数列的项数公式，来简化求前缀和的复杂度。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;
const int N = 2e5 + 7;

struct Node {
    int S;
    int E;
    int D;
};

Node node[N];

int main() {
    int T;
    cin >> T;
    
    while (T --) {
        int n;
        scanf("%d", &n);
        
        int maxe = -1;
        for (int i = 0; i < n; i ++) {
            scanf("%d %d %d", &node[i].S, &node[i].E, &node[i].D);
            maxe = max(maxe, node[i].E);
        }
        
        auto get_sum = [&](int m) -> int {
            // 求区间1 ~ m点数的前缀和
            LL sum = 0;
            for (int i = 0; i < n; i ++) {
                // 小于等于的交集
                if (node[i].S <= m) {
                    sum += ((min(node[i].E, m) - node[i].S) / node[i].D + 1);
                }
                // 大于则交集为0个
            }
            return sum;
        };
        
        int l = 1, r = maxe;
        while (l != r + 1)  {
            int mid = l + (r - l) / 2;
            if (get_sum(mid) & 1) {
                r = mid - 1;
            }
            else {
                l = mid + 1;
            }
        }
        LL cnt = get_sum(l) - get_sum(l - 1);
        if (cnt & 1) printf ("%d %lld\n", l, cnt);
        else printf("There's no weakness.\n");
    }
    
    return 0;
}
```

#### 复杂度分析

- 时间复杂度${O(n\log n)}$， 其中$nlogn$为二分查找的时间复杂度。

- 空间复杂度${O(N)}$, 主要消耗空间的为数组$node[N]$。